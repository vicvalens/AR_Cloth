<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Try-On Web POC v2 (Auto-hombros con MediaPipe Pose)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 16px; }
    .wrap { max-width: 980px; margin: 0 auto; display: grid; gap: 12px; }
    .controls { display: grid; gap: 10px; padding: 12px; border: 1px solid #ddd; border-radius: 12px; }
    .row { display: grid; gap: 8px; grid-template-columns: 1fr 1fr; }
    .row > label { display: grid; gap: 6px; font-size: 14px; }
    canvas { width: 100%; height: auto; border: 1px solid #ddd; border-radius: 12px; background: #f7f7f7; touch-action: none; }
    .hint { font-size: 13px; color: #444; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button:active { transform: translateY(1px); }
    .btns { display: flex; gap: 10px; flex-wrap: wrap; }
    .badge { font-size: 12px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 999px; display: inline-block; }
    @media (max-width: 720px) { .row { grid-template-columns: 1fr; } }
  </style>

  <!-- MediaPipe Pose (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>

<body>
  <div class="wrap">
    <h2>Try-On Web POC v2: Foto + playera auto-colocada por hombros</h2>
    <p class="hint">
      1) Sube foto frontal. 2) Click en “Auto-colocar”. 3) Ajusta si hace falta.
      <span class="badge" id="status">Listo</span>
    </p>

    <div class="controls">
      <div class="row">
        <label>
          Foto del usuario (JPG/PNG)
          <input id="photoInput" type="file" accept="image/*" />
        </label>

        <label>
          Prenda (PNG transparente)
          <input id="garmentInput" type="file" accept="image/png" />
          <span class="hint">Opcional: si no subes, usa shirt.png en la carpeta.</span>
        </label>
      </div>

      <div class="row">
        <label>
          Escala fina
          <input id="scaleFine" type="range" min="0.7" max="1.3" value="1" step="0.01" />
        </label>

        <label>
          Offset vertical (subir/bajar)
          <input id="yOffset" type="range" min="-250" max="250" value="0" step="1" />
        </label>
      </div>

      <div class="row">
        <label>
          Rotación fina (grados)
          <input id="rotFine" type="range" min="-15" max="15" value="0" step="0.1" />
        </label>

        <label>
          Opacidad
          <input id="opacity" type="range" min="0.1" max="1" value="0.95" step="0.01" />
        </label>
      </div>

      <div class="btns">
        <button id="autoBtn">Auto-colocar (hombros)</button>
        <button id="toggleSkeletonBtn">Ver puntos (debug)</button>
        <button id="resetBtn">Reset</button>
        <button id="downloadBtn">Descargar resultado</button>
      </div>

      <p class="hint">
        Esto usa pose estimation para encontrar hombros. No hay oclusión ni tela real.
        Si la foto es frontal y con buena luz, funciona mucho mejor.
      </p>
    </div>

    <canvas id="c" width="1080" height="1350"></canvas>

    <!-- Imagen oculta para procesar Pose -->
    <img id="hiddenPhoto" alt="" style="display:none;" />
  </div>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const statusEl = document.getElementById("status");
    const photoInput = document.getElementById("photoInput");
    const garmentInput = document.getElementById("garmentInput");

    const scaleFineEl = document.getElementById("scaleFine");
    const yOffsetEl = document.getElementById("yOffset");
    const rotFineEl = document.getElementById("rotFine");
    const opacityEl = document.getElementById("opacity");

    const autoBtn = document.getElementById("autoBtn");
    const toggleSkeletonBtn = document.getElementById("toggleSkeletonBtn");
    const resetBtn = document.getElementById("resetBtn");
    const downloadBtn = document.getElementById("downloadBtn");

    const hiddenPhoto = document.getElementById("hiddenPhoto");

    let photoImg = null;
    let garmentImg = new Image();
    garmentImg.crossOrigin = "anonymous";

    let showSkeleton = false;
    let lastPoseLandmarks = null;

    // Transform de la prenda
    const garment = {
      x: canvas.width * 0.5,
      y: canvas.height * 0.52,
      scale: 1,
      rotDeg: 0,
      opacity: parseFloat(opacityEl.value),
      baseW: 700,
      baseH: 800
    };

    // --- Helpers dibujo ---
    function setStatus(txt) { statusEl.textContent = txt; }

    function fitPhotoToCanvas(img) {
      const cw = canvas.width, ch = canvas.height;
      const iw = img.width, ih = img.height;
      const s = Math.max(cw / iw, ch / ih);
      const nw = iw * s, nh = ih * s;
      const dx = (cw - nw) / 2;
      const dy = (ch - nh) / 2;
      ctx.drawImage(img, dx, dy, nw, nh);
      return { dx, dy, s, nw, nh };
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let photoMap = null;
      if (photoImg) {
        photoMap = fitPhotoToCanvas(photoImg);
      } else {
        ctx.fillStyle = "#f7f7f7";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#666";
        ctx.font = "28px system-ui";
        ctx.fillText("Sube una foto para empezar", 60, 90);
      }

      // Prenda
      if (garmentImg && garmentImg.complete && garmentImg.naturalWidth > 0) {
        ctx.save();
        ctx.globalAlpha = garment.opacity;

        const rot = garment.rotDeg * Math.PI / 180;
        ctx.translate(garment.x, garment.y);
        ctx.rotate(rot);
        ctx.scale(garment.scale, garment.scale);

        ctx.drawImage(garmentImg, -garment.baseW/2, -garment.baseH/2, garment.baseW, garment.baseH);

        ctx.restore();
        ctx.globalAlpha = 1;
      }

      // Debug skeleton (sobre canvas)
      if (showSkeleton && lastPoseLandmarks && photoImg) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,255,0.7)";
        // Dibujamos solo hombros para debug
        const LS = lastPoseLandmarks[11]; // left shoulder
        const RS = lastPoseLandmarks[12]; // right shoulder
        // landmarks están en coords normalizadas del input image (hiddenPhoto)
        // No tenemos mapeo exacto a canvas si la hiddenPhoto tiene dims distintas del canvas.
        // Para evitar líos, solo indicamos que hay detección activa.
        ctx.font = "22px system-ui";
        ctx.fillText("Pose detectada (hombros)", 60, 130);
        ctx.restore();
      }

      // Borde
      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,0.12)";
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      ctx.restore();
    }

    function reset() {
      garment.x = canvas.width * 0.5;
      garment.y = canvas.height * 0.52;
      garment.scale = 1;
      garment.rotDeg = 0;
      garment.opacity = 0.95;

      scaleFineEl.value = 1;
      yOffsetEl.value = 0;
      rotFineEl.value = 0;
      opacityEl.value = 0.95;

      lastPoseLandmarks = null;
      setStatus("Listo");
      draw();
    }

    // --- MediaPipe Pose setup ---
    const pose = new Pose.Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      selfieMode: false
    });

    pose.onResults((results) => {
      lastPoseLandmarks = results.poseLandmarks || null;
      draw();
      setStatus(lastPoseLandmarks ? "Pose detectada" : "Sin pose");
    });

    async function runPoseOnHiddenPhoto() {
      if (!hiddenPhoto.src) return;
      setStatus("Detectando pose…");
      await pose.send({ image: hiddenPhoto });
    }

    // --- Auto-colocación por hombros ---
    function autoPlaceFromShoulders() {
      if (!lastPoseLandmarks || !photoImg || !hiddenPhoto.width) {
        alert("Primero sube una foto y corre detección (Auto-colocar).");
        return;
      }

      // Landmarks vienen normalizados (0..1) respecto al tamaño de hiddenPhoto (naturalWidth/Height)
      const LS = lastPoseLandmarks[11]; // left shoulder
      const RS = lastPoseLandmarks[12]; // right shoulder
      if (!LS || !RS) {
        alert("No detecté hombros con confianza. Usa una foto más frontal/iluminada.");
        return;
      }

      // Convertimos coords a pixeles en hiddenPhoto
      const iw = hiddenPhoto.naturalWidth;
      const ih = hiddenPhoto.naturalHeight;

      const lsx = LS.x * iw, lsy = LS.y * ih;
      const rsx = RS.x * iw, rsy = RS.y * ih;

      // Distancia entre hombros en la foto (pixeles)
      const dx = (lsx - rsx);
      const dy = (lsy - rsy);
      const shoulderDist = Math.sqrt(dx*dx + dy*dy);

      // Rotación base (ángulo de línea de hombros)
      const angleRad = Math.atan2(dy, dx);
      const angleDeg = angleRad * 180 / Math.PI;

      // Ahora mapeamos esas coords al canvas (porque dibujamos la foto "cover")
      // Recalculamos cómo se dibuja photoImg en canvas para convertir puntos:
      // Mapeo: canvasX = drawDx + photoX * s; canvasY = drawDy + photoY * s
      ctx.save();
      // Hacemos un cálculo igual al draw (cover):
      const cw = canvas.width, ch = canvas.height;
      const s = Math.max(cw / iw, ch / ih);
      const nw = iw * s, nh = ih * s;
      const drawDx = (cw - nw) / 2;
      const drawDy = (ch - nh) / 2;

      const lsCanvasX = drawDx + lsx * s;
      const lsCanvasY = drawDy + lsy * s;
      const rsCanvasX = drawDx + rsx * s;
      const rsCanvasY = drawDy + rsy * s;

      // Centro hombros en canvas
      const cx = (lsCanvasX + rsCanvasX) / 2;
      const cy = (lsCanvasY + rsCanvasY) / 2;

      // Colocación: playera un poco debajo del centro de hombros
      garment.x = cx;
      garment.y = cy + 240 + parseFloat(yOffsetEl.value); // ajusta este 240 si tu PNG es distinto

      // Escala: relacionamos distancia hombros vs ancho base de prenda
      // Factor típico: la playera debe ser ~2.2x la distancia hombros (depende de recorte)
      const shoulderCanvasDist = shoulderDist * s;
      const targetGarmentWidth = shoulderCanvasDist * 2.2;
      garment.scale = targetGarmentWidth / garment.baseW;

      // Rotación base + rotFine
      garment.rotDeg = angleDeg + parseFloat(rotFineEl.value);

      // Escala fina multiplicativa
      garment.scale *= parseFloat(scaleFineEl.value);

      ctx.restore();
      draw();
      setStatus("Auto-colocado ✅");
    }

    // --- Inputs ---
    photoInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      const url = URL.createObjectURL(file);

      // Para canvas (photoImg)
      const img = new Image();
      img.onload = async () => {
        photoImg = img;
        draw();
        // Para pose: usar hiddenPhoto con el mismo src
        hiddenPhoto.onload = async () => {
          await runPoseOnHiddenPhoto();
          setStatus("Foto cargada");
        };
        hiddenPhoto.src = url; // reuse object URL
      };
      img.src = url;
    });

    function loadGarmentFromFile(file) {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        garmentImg = img;
        draw();
      };
      img.src = url;
    }

    garmentInput.addEventListener("change", (e) => {
      const file = e.target.files?.[0];
      if (file) loadGarmentFromFile(file);
    });

    scaleFineEl.addEventListener("input", () => { autoPlaceFromShoulders(); });
    yOffsetEl.addEventListener("input", () => { autoPlaceFromShoulders(); });
    rotFineEl.addEventListener("input", () => { autoPlaceFromShoulders(); });

    opacityEl.addEventListener("input", () => {
      garment.opacity = parseFloat(opacityEl.value);
      draw();
    });

    autoBtn.addEventListener("click", async () => {
      if (!photoImg) return alert("Sube una foto primero.");
      // Corre pose si aún no hay landmarks
      if (!lastPoseLandmarks) await runPoseOnHiddenPhoto();
      autoPlaceFromShoulders();
    });

    toggleSkeletonBtn.addEventListener("click", () => {
      showSkeleton = !showSkeleton;
      draw();
    });

    resetBtn.addEventListener("click", reset);

    downloadBtn.addEventListener("click", () => {
      const a = document.createElement("a");
      a.download = "tryon_pose_result.png";
      a.href = canvas.toDataURL("image/png");
      a.click();
    });

    // Init: carga shirt.png por defecto
    (function init() {
      garmentImg = new Image();
      garmentImg.onload = () => draw();
      garmentImg.onerror = () => {
        // no alert al inicio; si no existe, el usuario puede subir PNG
        draw();
      };
      garmentImg.src = "shirt.png";
      reset();
    })();
  </script>
</body>
</html>
