<script>
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const statusEl = document.getElementById("status");
  const compatMsg = document.getElementById("compatMsg");

  const photoInput = document.getElementById("photoInput");
  const garmentInput = document.getElementById("garmentInput");

  const scaleFineEl = document.getElementById("scaleFine");
  const yOffsetEl = document.getElementById("yOffset");
  const rotFineEl = document.getElementById("rotFine");
  const opacityEl = document.getElementById("opacity");

  const autoBtn = document.getElementById("autoBtn");
  const toggleSkeletonBtn = document.getElementById("toggleSkeletonBtn");
  const resetBtn = document.getElementById("resetBtn");
  const downloadBtn = document.getElementById("downloadBtn");

  const hiddenPhoto = document.getElementById("hiddenPhoto");

  // --- Detect iOS/WebKit (Chrome iOS también) ---
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
  const isWebKit = /AppleWebKit/i.test(navigator.userAgent);
  const useManualMode = isIOS && isWebKit; // fallback

  function setStatus(t) { statusEl.textContent = t; }

  let photoImg = null;
  let garmentImg = new Image();
  garmentImg.crossOrigin = "anonymous";

  let showSkeleton = false;
  let lastPoseLandmarks = null;

  // Transform de la prenda
  const garment = {
    x: canvas.width * 0.5,
    y: canvas.height * 0.52,
    scale: 1,
    rotDeg: 0,
    opacity: parseFloat(opacityEl.value),
    baseW: 700,
    baseH: 800
  };

  // --- Manual drag state ---
  let dragging = false;
  let dragOffsetX = 0, dragOffsetY = 0;

  function fitPhotoToCanvas(img) {
    const cw = canvas.width, ch = canvas.height;
    const iw = img.width, ih = img.height;
    const s = Math.max(cw / iw, ch / ih);
    const nw = iw * s, nh = ih * s;
    const dx = (cw - nw) / 2;
    const dy = (ch - nh) / 2;
    ctx.drawImage(img, dx, dy, nw, nh);
    return { dx, dy, s, iw, ih };
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (photoImg) {
      fitPhotoToCanvas(photoImg);
    } else {
      ctx.fillStyle = "#f7f7f7";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#666";
      ctx.font = "28px system-ui";
      ctx.fillText("Sube una foto para empezar", 60, 90);
    }

    // Prenda
    if (garmentImg && garmentImg.complete && garmentImg.naturalWidth > 0) {
      ctx.save();
      ctx.globalAlpha = garment.opacity;

      const rot = garment.rotDeg * Math.PI / 180;
      ctx.translate(garment.x, garment.y);
      ctx.rotate(rot);
      ctx.scale(garment.scale, garment.scale);

      ctx.drawImage(garmentImg, -garment.baseW/2, -garment.baseH/2, garment.baseW, garment.baseH);

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // Marco
    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.12)";
    ctx.lineWidth = 2;
    ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
    ctx.restore();
  }

  function reset() {
    garment.x = canvas.width * 0.5;
    garment.y = canvas.height * 0.52;
    garment.scale = 1;
    garment.rotDeg = 0;
    garment.opacity = 0.95;

    scaleFineEl.value = 1;
    yOffsetEl.value = 0;
    rotFineEl.value = 0;
    opacityEl.value = 0.95;

    lastPoseLandmarks = null;

    setStatus(useManualMode ? "Modo manual (iOS)" : "Listo");
    draw();
  }

  // ===== Manual interactions (siempre disponibles) =====
  function getPointerPos(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  function isOverGarment(px, py) {
    const w = garment.baseW * garment.scale;
    const h = garment.baseH * garment.scale;
    // hit test simple (sin rotación)
    return (px >= garment.x - w/2 && px <= garment.x + w/2 &&
            py >= garment.y - h/2 && py <= garment.y + h/2);
  }

  canvas.addEventListener("pointerdown", (ev) => {
    canvas.setPointerCapture(ev.pointerId);
    const p = getPointerPos(ev);
    if (isOverGarment(p.x, p.y)) {
      dragging = true;
      dragOffsetX = p.x - garment.x;
      dragOffsetY = p.y - garment.y;
    }
  });

  canvas.addEventListener("pointermove", (ev) => {
    if (!dragging) return;
    const p = getPointerPos(ev);
    garment.x = p.x - dragOffsetX;
    garment.y = p.y - dragOffsetY;
    draw();
  });

  canvas.addEventListener("pointerup", () => dragging = false);
  canvas.addEventListener("pointercancel", () => dragging = false);

  // sliders (manual siempre)
  opacityEl.addEventListener("input", () => {
    garment.opacity = parseFloat(opacityEl.value);
    draw();
  });

  // ===== Pose (solo si NO es iOS WebKit) =====
  let pose = null;

  async function runPoseOnHiddenPhoto() {
    if (!pose || !hiddenPhoto.src) return;
    setStatus("Detectando pose…");
    await pose.send({ image: hiddenPhoto });
  }

  function autoPlaceFromShoulders() {
    if (!lastPoseLandmarks || !photoImg || !hiddenPhoto.naturalWidth) return;

    const LS = lastPoseLandmarks[11];
    const RS = lastPoseLandmarks[12];
    if (!LS || !RS) return;

    const iw = hiddenPhoto.naturalWidth;
    const ih = hiddenPhoto.naturalHeight;

    const lsx = LS.x * iw, lsy = LS.y * ih;
    const rsx = RS.x * iw, rsy = RS.y * ih;

    const dx = (lsx - rsx);
    const dy = (lsy - rsy);
    const shoulderDist = Math.sqrt(dx*dx + dy*dy);

    const angleDeg = Math.atan2(dy, dx) * 180 / Math.PI;

    const cw = canvas.width, ch = canvas.height;
    const s = Math.max(cw / iw, ch / ih);
    const nw = iw * s, nh = ih * s;
    const drawDx = (cw - nw) / 2;
    const drawDy = (ch - nh) / 2;

    const lsCanvasX = drawDx + lsx * s;
    const lsCanvasY = drawDy + lsy * s;
    const rsCanvasX = drawDx + rsx * s;
    const rsCanvasY = drawDy + rsy * s;

    const cx = (lsCanvasX + rsCanvasX) / 2;
    const cy = (lsCanvasY + rsCanvasY) / 2;

    garment.x = cx;
    garment.y = cy + 240 + parseFloat(yOffsetEl.value);

    const shoulderCanvasDist = shoulderDist * s;
    const targetW = shoulderCanvasDist * 2.2;
    garment.scale = (targetW / garment.baseW) * parseFloat(scaleFineEl.value);

    garment.rotDeg = angleDeg + parseFloat(rotFineEl.value);

    draw();
    setStatus("Auto-colocado ✅");
  }

  // sliders que recalculan auto (solo desktop)
  function bindAutoSlidersIfDesktop() {
    if (useManualMode) return;
    scaleFineEl.addEventListener("input", () => autoPlaceFromShoulders());
    yOffsetEl.addEventListener("input", () => autoPlaceFromShoulders());
    rotFineEl.addEventListener("input", () => autoPlaceFromShoulders());
  }

  // ===== Inputs de archivos =====
  photoInput.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const url = URL.createObjectURL(file);

    const img = new Image();
    img.onload = async () => {
      photoImg = img;
      draw();

      hiddenPhoto.onload = async () => {
        if (!useManualMode) {
          await runPoseOnHiddenPhoto();
          setStatus(lastPoseLandmarks ? "Pose detectada" : "Sin pose");
        } else {
          setStatus("Modo manual (iOS) ✅");
        }
      };
      hiddenPhoto.src = url;
    };
    img.src = url;
  });

  garmentInput.addEventListener("change", (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      garmentImg = img;
      draw();
    };
    img.src = url;
  });

  // Botones
  autoBtn.addEventListener("click", async () => {
    if (useManualMode) return; // está desactivado en iOS
    if (!photoImg) return alert("Sube una foto primero.");
    if (!lastPoseLandmarks) await runPoseOnHiddenPhoto();
    autoPlaceFromShoulders();
  });

  toggleSkeletonBtn.addEventListener("click", () => {
    showSkeleton = !showSkeleton;
    draw();
  });

  resetBtn.addEventListener("click", reset);

  downloadBtn.addEventListener("click", () => {
    const a = document.createElement("a");
    a.download = "tryon_result.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  });

  // ===== Init =====
  (async function init() {
    // Cargar prenda default (shirt.png)
    garmentImg = new Image();
    garmentImg.onload = () => draw();
    garmentImg.src = "shirt.png";

    if (useManualMode) {
      // iOS fallback
      compatMsg.textContent =
        "iPhone/iPad: modo manual (ajuste por arrastre). Auto-ajuste por hombros se activa en desktop.";
      autoBtn.disabled = true;
      autoBtn.textContent = "Auto-colocar (desktop)";
      toggleSkeletonBtn.disabled = true;
      setStatus("Modo manual (iOS)");
    } else {
      compatMsg.textContent =
        "Desktop: auto-ajuste por hombros activado (MediaPipe Pose).";
      // Inicializar MediaPipe Pose
      pose = new Pose.Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
      });
      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        selfieMode: false
      });
      pose.onResults((results) => {
        lastPoseLandmarks = results.poseLandmarks || null;
        draw();
        setStatus(lastPoseLandmarks ? "Pose detectada" : "Sin pose");
      });

      bindAutoSlidersIfDesktop();
      setStatus("Listo (desktop)");
    }

    reset();
  })();
</script>
