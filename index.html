<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Try-On Web POC (Playera / Vestido)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 16px; }
    .wrap { max-width: 980px; margin: 0 auto; display: grid; gap: 12px; }
    .controls { display: grid; gap: 10px; padding: 12px; border: 1px solid #ddd; border-radius: 12px; }
    .row { display: grid; gap: 8px; grid-template-columns: 1fr 1fr; }
    .row > label { display: grid; gap: 6px; font-size: 14px; }
    canvas { width: 100%; height: auto; border: 1px solid #ddd; border-radius: 12px; background: #f7f7f7; touch-action: none; }
    .hint { font-size: 13px; color: #444; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button:active { transform: translateY(1px); }
    .btns { display: flex; gap: 10px; flex-wrap: wrap; }
    @media (max-width: 720px) { .row { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Try-On Web POC (sin IA): foto + prenda superpuesta</h2>
    <p class="hint">
      1) Sube una foto frontal. 2) Elige prenda. 3) Arrastra la prenda en el canvas.
      <br/>Tip: usa PNG con fondo transparente para la prenda (shirt.png / dress.png).
    </p>

    <div class="controls">
      <div class="row">
        <label>
          Foto del usuario (JPG/PNG)
          <input id="photoInput" type="file" accept="image/*" />
        </label>

        <label>
          Prenda (PNG transparente)
          <select id="garmentSelect">
            <option value="shirt.png">Playera (shirt.png)</option>
            <option value="dress.png">Vestido (dress.png)</option>
          </select>
        </label>
      </div>

      <div class="row">
        <label>
          Escala
          <input id="scale" type="range" min="0.2" max="2.5" value="1" step="0.01" />
        </label>

        <label>
          Rotación (grados)
          <input id="rotation" type="range" min="-45" max="45" value="0" step="0.5" />
        </label>
      </div>

      <div class="row">
        <label>
          Opacidad
          <input id="opacity" type="range" min="0.1" max="1" value="0.95" step="0.01" />
        </label>

        <label>
          Modo
          <select id="blend">
            <option value="source-over">Normal</option>
            <option value="multiply">Multiply (se integra mejor)</option>
            <option value="overlay">Overlay</option>
          </select>
        </label>
      </div>

      <div class="btns">
        <button id="centerBtn">Centrar prenda</button>
        <button id="resetBtn">Reset</button>
        <button id="downloadBtn">Descargar resultado</button>
      </div>

      <p class="hint">
        Nota: Esto NO hace body tracking. Es una base de demo web (flujo + UI).
        La siguiente fase sería: detectar hombros/cadera con pose estimation y auto-colocar.
      </p>
    </div>

    <canvas id="c" width="1080" height="1350"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const photoInput = document.getElementById("photoInput");
    const garmentSelect = document.getElementById("garmentSelect");
    const scaleEl = document.getElementById("scale");
    const rotEl = document.getElementById("rotation");
    const opacityEl = document.getElementById("opacity");
    const blendEl = document.getElementById("blend");

    const centerBtn = document.getElementById("centerBtn");
    const resetBtn = document.getElementById("resetBtn");
    const downloadBtn = document.getElementById("downloadBtn");

    let photoImg = null;
    let garmentImg = new Image();
    garmentImg.crossOrigin = "anonymous";

    // Estado de la prenda (posición/transform)
    const garment = {
      x: canvas.width * 0.5,
      y: canvas.height * 0.52,
      scale: parseFloat(scaleEl.value),
      rotDeg: parseFloat(rotEl.value),
      opacity: parseFloat(opacityEl.value),
      blend: blendEl.value,
      baseW: 600, // tamaño base de dibujo (ajústalo según tu PNG)
      baseH: 700
    };

    // Drag
    let dragging = false;
    let dragOffsetX = 0, dragOffsetY = 0;

    function loadGarment(src) {
      garmentImg = new Image();
      garmentImg.onload = () => draw();
      garmentImg.onerror = () => {
        alert(`No pude cargar "${src}". Asegúrate de que exista en la misma carpeta.`);
      };
      garmentImg.src = src;
    }

    function fitPhotoToCanvas(img) {
      // Dibuja la foto cubriendo el canvas (cover) manteniendo proporción
      const cw = canvas.width, ch = canvas.height;
      const iw = img.width, ih = img.height;

      const scale = Math.max(cw / iw, ch / ih);
      const nw = iw * scale;
      const nh = ih * scale;

      const dx = (cw - nw) / 2;
      const dy = (ch - nh) / 2;

      ctx.drawImage(img, dx, dy, nw, nh);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Fondo: foto o placeholder
      if (photoImg) {
        fitPhotoToCanvas(photoImg);
      } else {
        // placeholder
        ctx.fillStyle = "#f7f7f7";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#666";
        ctx.font = "28px system-ui";
        ctx.fillText("Sube una foto para empezar", 60, 90);
      }

      // Prenda
      if (garmentImg && garmentImg.complete && garmentImg.naturalWidth > 0) {
        ctx.save();
        ctx.globalAlpha = garment.opacity;
        ctx.globalCompositeOperation = garment.blend;

        const rot = garment.rotDeg * Math.PI / 180;

        ctx.translate(garment.x, garment.y);
        ctx.rotate(rot);
        ctx.scale(garment.scale, garment.scale);

        // Dibujo centrado
        const w = garment.baseW;
        const h = garment.baseH;

        ctx.drawImage(garmentImg, -w/2, -h/2, w, h);

        ctx.restore();

        // Regresa a normal
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
      }

      // Guía simple
      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,0.12)";
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      ctx.restore();
    }

    function reset() {
      garment.x = canvas.width * 0.5;
      garment.y = canvas.height * 0.52;
      garment.scale = 1;
      garment.rotDeg = 0;
      garment.opacity = 0.95;
      garment.blend = "source-over";

      scaleEl.value = garment.scale;
      rotEl.value = garment.rotDeg;
      opacityEl.value = garment.opacity;
      blendEl.value = garment.blend;

      draw();
    }

    function centerGarment() {
      garment.x = canvas.width * 0.5;
      garment.y = canvas.height * 0.52;
      draw();
    }

    function getPointerPos(ev) {
      const rect = canvas.getBoundingClientRect();
      const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
      const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
      return { x, y };
    }

    // Hit test aproximado (caja axis-aligned)
    function isOverGarment(px, py) {
      const w = garment.baseW * garment.scale;
      const h = garment.baseH * garment.scale;
      // Simplificación: no considera rotación. Para demo está ok.
      return (px >= garment.x - w/2 && px <= garment.x + w/2 &&
              py >= garment.y - h/2 && py <= garment.y + h/2);
    }

    // Inputs
    photoInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        photoImg = img;
        URL.revokeObjectURL(url);
        draw();
      };
      img.src = url;
    });

    garmentSelect.addEventListener("change", () => loadGarment(garmentSelect.value));

    scaleEl.addEventListener("input", () => {
      garment.scale = parseFloat(scaleEl.value);
      draw();
    });

    rotEl.addEventListener("input", () => {
      garment.rotDeg = parseFloat(rotEl.value);
      draw();
    });

    opacityEl.addEventListener("input", () => {
      garment.opacity = parseFloat(opacityEl.value);
      draw();
    });

    blendEl.addEventListener("change", () => {
      garment.blend = blendEl.value;
      draw();
    });

    centerBtn.addEventListener("click", centerGarment);
    resetBtn.addEventListener("click", reset);

    downloadBtn.addEventListener("click", () => {
      const a = document.createElement("a");
      a.download = "tryon_result.png";
      a.href = canvas.toDataURL("image/png");
      a.click();
    });

    // Pointer events (mouse/touch)
    canvas.addEventListener("pointerdown", (ev) => {
      canvas.setPointerCapture(ev.pointerId);
      const p = getPointerPos(ev);
      if (isOverGarment(p.x, p.y)) {
        dragging = true;
        dragOffsetX = p.x - garment.x;
        dragOffsetY = p.y - garment.y;
      }
    });

    canvas.addEventListener("pointermove", (ev) => {
      if (!dragging) return;
      const p = getPointerPos(ev);
      garment.x = p.x - dragOffsetX;
      garment.y = p.y - dragOffsetY;
      draw();
    });

    canvas.addEventListener("pointerup", () => dragging = false);
    canvas.addEventListener("pointercancel", () => dragging = false);

    // Init
    loadGarment(garmentSelect.value);
    draw();
  </script>
</body>
</html>
